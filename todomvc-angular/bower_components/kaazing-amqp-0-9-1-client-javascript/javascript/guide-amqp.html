<!--

    Copyright (c) 2007-2014, Kaazing Corporation. All rights reserved.

-->

<!DOCTYPE html>
<head>
<!--

    Copyright (c) 2007-2014, Kaazing Corporation. All rights reserved.

-->
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
    
        <!-- Required for IE6/IE7 cross-origin support -->
        <meta name="kaazing:postMessageBridgeURL" content="PostMessageBridge.html">

        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <link rel="icon" href="../../../resources/images/favicon.ico">
        <title>Kaazing | Demos</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">

        <link rel="stylesheet" href="resources/css/normalize.css">
        <link rel="stylesheet" href="resources/css/dev.css">
        <link rel="stylesheet" href="resources/css/demo.css">
        <!--[if lte IE 7]> <link rel="stylesheet" href="../../../resources/css/demo-ie.css"> <![endif]-->

        <script src="resources/js/jquery-1.9.1.min.js"></script>
        <script src="resources/js/modernizr.js"></script>

        <!--  Kaazing scripts -->
        <script type="text/javascript" language="javascript" src="WebSocket.js"></script>
        <script type="text/javascript" language="javascript" src="Amqp-0-9-1-debug.js"></script>

	<style type="text/css" media="screen">
	#middle input {
		width: auto;
		margin-right: 10px;
	}
	#middle label {
		width: auto;
		text-align: left;
		margin-right: 0px;
	}
	</style>
  <script>
    var $ = function(s) { return document.getElementById(s); };

    var log = function(destination, message, raw) {
      var pre = document.createElement("pre");
      var line = document.createElement("div");
      pre.style.wordWrap = "break-word";
      pre.innerHTML = message;

        line.appendChild(pre);
        if (raw) {
            var markup = document.createElement("div");
            markup.innerHTML = raw;
            line.appendChild(markup);
        }
        $(destination).insertBefore(line, $(destination).firstChild);

      while ($(destination).childNodes.length > 500)
      {
        $(destination).removeChild(console.lastChild);
      }
    }

    // array of current channels
    // this is used to populate channel selection lists
    var channels = [];
    var channelLists = ["channelCloseChannel", "publishChannel", "txChannel", "consumeChannel", "exchangesChannel", "queuesChannel", "bindChannel", "flowChannel"];

    var amqpClientFactory = new Kaazing.AMQP.AmqpClientFactory();

    // Creating the WebSocketFactory once and decorating it as desired lets
    // you reuse it for multiple AMQP clients.
    var webSocketFactory;
    if (Kaazing.Gateway && typeof(Kaazing.Gateway.WebSocketFactory) === "function") {
        webSocketFactory = new Kaazing.Gateway.WebSocketFactory();
        amqpClientFactory.setWebSocketFactory(webSocketFactory);
    }

    var stringToArrayBuffer = function(str) {
        var buf = new ArrayBuffer(str.length);
        var bufView = new Uint8Array(buf);
        for (var i=0, strLen=str.length; i<strLen; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }

    var arrayBufferToString = function(buf) {
        return String.fromCharCode.apply(null, new Uint8Array(buf));
    }


    var removeChannel = function(id) {
        var newChannels = [];
        for (var i=0; i<channels.length; i++) {
            if (channels[i]._id != id) {
                newChannels.push(channels[i]);
            }
        }
        channels = newChannels;
        updateChannels();
    }

    var setup = function() {
        $("url").value = "ws://sandbox.kaazing.net:80/amqp091";
        $("username").value = "guest";
        $("password").value = "guest";
        $("virtualhost").value = "/";


        // set button handlers
        $("connect").onclick = function () {
            var virtualHost = $("virtualhost").value
            var credentials = {};
            credentials.username = $('username').value;
            credentials.password = $('password').value;

            connection = amqpClientFactory.createAmqpClient();
            connection.connect($("url").value, virtualHost, credentials, function() { setStatus("Connected");} );

        };

        $("disconnect").onclick = function() {
            connection.disconnect();

            setStatus("Not connected");
            channels=[];
            connection = null;
        }

        $("openChannel").onclick = function() {
            var channel = connection.openChannel(function(){updateChannels();});
            channel.addEventListener("close", function() {
                removeChannel(channel._id);
            });


            channel.addEventListener("message", messageHandler);

            channels.push(channel);
        };

        $("closeChannel").onclick = function() {
            var channelId = $("channelCloseChannel").value;
            var channel = null;
            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                return;
            }

            channel.closeChannel(0, "", 0, 0);

        };

        $("declareQueue").onclick = function() {
            var channelId = $("queuesChannel").value;
            var channel = null;
            var output= "queueoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log("queueoutput", "select a valid channel");
                return;
            }

            var queueName = $("queueNameQ").value;

            var passive = $('passiveQ').checked;
            var durable = $('durableQ').checked;
            var exclusive = $('exclusiveQ').checked;
            var autoDelete = $('autodeleteQ').checked;
            var noWait = $('nowaitQ').checked;

            channel.declareQueue(queueName, passive, durable, exclusive, autoDelete, noWait, null, function(e) { log(output, queueName + " has " + e.args.messageCount + " messages and " + e.args.consumerCount + " consumers");}, errorHandler(output));

        };


        $("declareExchange").onclick = function() {
            var channelId = $("exchangesChannel").value;
            var channel = null;
            var output="exchangeoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log("exchangeoutput", "select a valid channel");
                return;
            }

            var exchangeName = $("exchangename").value;
            var exchangeType = $("exchangetype").options[$("exchangetype").selectedIndex].text;

            var passive = $('passiveE').checked;
            var durable = $('durableE').checked;
            var noWait = $('nowaitE').checked;

            channel.declareExchange(exchangeName, exchangeType, passive, durable, noWait, null, function(e) { log(output, exchangeName + " declared");}, errorHandler(output) );

        };


        $("bind").onclick = function() {
            var channelId = $("bindChannel").value;
            var channel = null;
            var output = "bindoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }

            var queueName = $("queuenameB").value;
            var exchangeName = $("exchangenameB").value;
            var routingkey = $("routingkeyB").value;

            var noWait = $('nowaitB').checked;

            channel.bindQueue(queueName, exchangeName, routingkey, noWait, null, function(e) { log(output, exchangeName + " bound");}, errorHandler(output));

        };


        /**
         * publish click handler
         */
        $("send").onclick = function() {
        var msg = $('textmessagePub').value;

        if(msg == null ||
           msg.length == 0)  {
            alert("Enter a valid string for message");
                return;
        }

            var channelId = $("publishChannel").value;
            var channel = null;

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }

            var exchangeName = $("exchangenamePub").value;
            var routingkey = $("routingkeyPub").value;

            var mandatory = $('mandatoryPub').checked;
            var immediate = $('immediatePub').checked;


            var body = null;

            // Older browsers like IE6 or IE7 don't support ArrayBuffer, therefore
            // the package the using a Kaazing ByteBuffer.
            if (typeof(ArrayBuffer) === "undefined") {
                body = new Kaazing.ByteBuffer();
                body.putString($('textmessagePub').value, Kaazing.Charset.UTF8);
                body.flip();
            }
            else {
                body = stringToArrayBuffer($('textmessagePub').value);
            }

            var headers = {};

            channel.publishBasic(body, headers, exchangeName, routingkey, mandatory, immediate);

        };

        $("consume").onclick = function() {
            var channelId = $("consumeChannel").value;
            var channel = null;
            var output = "consumeoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");

                return;
            }

            var queuename = $("queuenameCon").value;
            var consumerTag = $("consumertagCon").value;

            var nolocal = $('nolocalCon').checked;
            var noack = $('noackCon').checked;
            var nowait = $('nowaitCon').checked;
            var exclusive = $('exclusiveCon').checked;


            channel.consumeBasic(queuename, consumerTag, nolocal, noack, nowait, exclusive, null, function() { log(output, "Subscribed"); }, errorHandler(output));

        };


        $("cancel").onclick = function() {
            var channelId = $("consumeChannel").value;
            var channel = null;
            var output = "consumeoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }

            var consumerTag = $("consumertagCon").value;
            var nowait = $('nowaitCon').checked;



            channel.cancelBasic(consumerTag, nowait, function() { log(output, "Canceled"); }, errorHandler(output));

        };


        $("select").onclick = function() {
            var channelId = $("txChannel").value;
            var channel = null;
            var output = "txoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }
            channel.selectTx(function() {log(output, "Select succeeded");}, errorHandler(output));
        }

        $("commit").onclick = function() {
            var channelId = $("txChannel").value;
            var channel = null;
            var output = "txoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }
            channel.commitTx(function() {log(output, "Commit succeeded");}, errorHandler(output));
        }

        $("rollback").onclick = function() {
            var channelId = $("txChannel").value;
            var channel = null;
            var output = "txoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }
            channel.rollbackTx(function() {log(output, "Rolled back");}, errorHandler(output));
        }

        $("trueFlow").onclick = function() {
            var channelId = $("flowChannel").value;
            var channel = null;
            var output = "flowoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }
            channel.flowChannel(true, function() {log(output, "Flow control set to true");}, errorHandler(output));
        }

        $("falseFlow").onclick = function() {
            var channelId = $("flowChannel").value;
            var channel = null;
            var output = "flowoutput";

            // find channel in channel list
            for (var i=0; i<channels.length; i++) {
                if (channels[i]._id == channelId) {
                    channel = channels[i];
                    break;
                }
            }
            if (!channel) {
                log(output, "select a valid channel");
                return;
            }
            channel.flowChannel(false, function() {log(output, "Flow control set to false");}, errorHandler(output) );
        }

        setStatus("Not connected");
    };

    var setStatus = function(s) {
        $('status').innerHTML = s;
        if (s === "Connected") {
            $('status').style.color = "green";
        } else {
            $('status').style.color = "red";
        }
    }

    var updateChannels = function() {
        var newChannels = [];
        for (var i=0; i<channels.length; i++) {
            newChannels.push(channels[i]._id);
        }

        // Replace channel lists in the page with the new list.
        //
        // (There is an IE bug that makes us do this with
        //   DOM manipulation instead of making the list
        //   once and copying its contents.)
        //
        // http://support.microsoft.com/kb/276228

        // replace channel lists in the page with the new list
        for (var i=0; i<channelLists.length; i++) {
            var list = $(channelLists[i]);

            // empty list
            while(list.firstChild) {
                list.removeChild(list.firstChild);
            }

            for (var j=0; j<newChannels.length; j++) {

                var elt = document.createElement("option");
                elt.value = newChannels[j];
                elt.label = newChannels[j];
                elt.text = newChannels[j];
                list.appendChild(elt);
            }
        }

    }


    var messageHandler = function(e) {
        var tag = e.args.deliveryTag;
        var body = null;

        // Check how the payload was packaged since older browsers like IE7 don't
        // support ArrayBuffer. In those cases, a Kaazing ByteBuffer was used instead.
        if (typeof(ArrayBuffer) === "undefined") {
            body = e.getBodyAsByteBuffer().getString(Kaazing.Charset.UTF8);
        }
        else {
            body = arrayBufferToString(e.getBodyAsArrayBuffer())
        }

        log("consumeoutput", body, "<button onclick='ackHandler("+tag+");this.disabled=true;'>Ack</button>" );
    }

    var errorHandler =  function errorHandler(form) {
        return function(e) {
            log(form, e.args.replyText);
        }
    };

    var ackHandler = function(n) {
        var channelId = $("consumeChannel").value;
        var channel = null;
        var output = "consumeoutput";

        // find channel in channel list
        for (var i=0; i<channels.length; i++) {
            if (channels[i]._id == channelId) {
                channel = channels[i];
                break;
            }
        }
        if (!channel) {
            log(output, "select a valid channel");
            return;
        }

        channel.ackBasic(n, false);
    }

    window.onload = setup;

  </script>

<title>Real-Time Interactive Guide to AMQP</title>
</head>
<body>
        <div class="main-container ">
            <div class="main wrapper clearfix">
            
                <div class="powered-wrapper">
                    <div class="powered-header"></div>
                </div>
                
<!-- End header -->

                <article>
                
                    <ul class="breadcrumbs clearfix">
                       <li>Real-Time Interactive Guide to AMQP</li>
                    </ul>

                    <section>
											
    <div id="main_header">
        <h1>Real-Time Interactive Guide to AMQP</h1>

<p><strong>Technology used</strong>: AMQP 0-9-1 and Kaazing WebSocket Gateway</p>
<p>The following is an interactive guide that takes you step-by-step through the main features of the Advanced Message Queuing Protocol (AMQP). This document contains the following sections:</p>
<ul class="arrow-2">
  <li><a href="#about_amqp">About AMQP</a></li>
  <li><a href="#about_rt_guide">About This Real-Time Interactive Guide</a></li>
  <li><a href="#connect_broker">Connecting to an AMQP Broker</a></li>
  <li><a href="#create_channels">Creating Channels</a></li>
  <li><a href="#creating_exchanges">Declaring an Exchange</a></li>
  <li><a href="#creating_queues">Declaring a Queue</a></li>
  <li><a href="#binding_queues">Binding an Exchange to a Queue</a></li>
  <li><a href="#publishing_messages">Publishing Messages</a></li>
  <li><a href="#consuming_messages">Consuming Messages</a></li>
  <li><a href="#using_transactions">Using Transactions</a></li>
  <li><a href="#control_flow">Controlling Message Flow</a></li>
      <li><a href="#summary">Summary</a></li>
</ul>
<h2><a name="about_amqp"></a>About AMQP</h2>
<p>AMQP is an open standard for messaging middleware originally designed by the financial services industry to provide an interoperable protocol for managing the flow of enterprise messages. AMQP uses a compact, efficient binary format for messaging and specifies  both messaging capabilities and a network wire-level protocol. For more information about  AMQP, visit <a href="http://www.amqp.org" class="code_inline">http://www.amqp.org</a>.</p>
<p>The 0-9-1 AMQP model defines the following components:</p>
<ul class="arrow-2">
  <li><strong>Exchange</strong>--clients publish messages to an exchange</li>
  <li><strong>Queue</strong>--clients read messages from a queue</li>
  <li><strong>Binding</strong>--a mapping from an exchange to a queue</li>
  </ul>
<p>An AMQP client connects to an AMQP broker and opens a channel. Once the channel is established, the client  can send messages to an exchange  and receive messages from a queue.</p>
<h2><strong><a name="about_rt_guide"></a>About This Real-Time Interactive Guide</strong></h2>
<p>This isn't your ordinary animated demo; instead, this is a real-time HTML5 Web page that communicates natively with an AMQP broker using a  bidirectional WebSocket connection--provided by Kaazing WebSocket Gateway--which reliably extends the AMQP messaging protocol to the Web with ultra high performance and minimal latency. If you'd like to see the code that was used to build this real-time Web page,  check the source of this  page and refer to the document <a href="http://developer.kaazing.com/documentation/amqp/4.0/dev-js/o_dev_js.html">Checklist: How to Build JavaScript Clients Using Kaazing WebSocket Gateway</a>.</p>
<span class="note"> <b>Notes:</b><br>
<ul class="arrow-2">
  <li>This guide uses version 0-9-1 of the AMQP protocol.</li>
  <li>To use this interactive guide, you must install and run the Kaazing WebSocket Gateway bundle and an AMQP Message broker as described in <a href="http://developer.kaazing.com/documentation/amqp/4.0/about/setup-guide.html" title="Kaazing | Documentation">Setting Up Kaazing WebSocket Gateway</a>.</li>
  </ul>
</span>
<h2><a name="connect_broker"></a>Connecting to an AMQP Broker</h2>

<p>Before you can use the messaging features of an AMQP broker, you must establish a connection to the broker by specifying the broker address, a user name and  password, and, optionally, a virtual host  name (the name of a collection of exchanges and queues hosted on independent server domains). An AMQP client generally  manages all of its communication on a single connection to an AMQP broker.</p>


<p>First, you must connect the client with an AMQP broker. To do this, perform the following steps:</p>
<ol>
  <li>Accept the default values for all text boxes.</li>
  <li><p>Click <strong>Connect</strong>.</p>
    <p>The status should change from <span class="code_inline">Not connected</span> to <span class="code_inline">Connected</span>. The <strong>Location</strong> text box specifies a WebSocket URL (by default <span class="code_inline">ws://sandbox.kaazing.net:80/amqp091</span>) to your  AMQP broker. The WebSocket connectivity is enabled by Kaazing WebSocket Gateway.</p></li>
  </ol>

    <fieldset>
        <legend>Connect to AMQP Broker</legend>

        <label for="url">Location</label>
        <input type="text" id="url">

        <label for="virtualhost">Virtual Host</label>
        <input type="text" id="virtualhost">

        <label for="username">User Name</label>
        <input type="text" id="username">

        <label for="password">Password</label>
        <input type="password" id="password">

        <br>

        <button id="connect">Connect</button>
        <button id="disconnect">Disconnect</button>

        <br>
        <br>
        <p>Status: <span id="status"></span></p>
    </fieldset>


    <h2> <a name="create_channels"></a>Creating Channels</h2>

    <p>Once a connection to an AMQP broker has been established, the client must create a  channel to communicate to the broker. A channel is a bi-directional connection between an AMQP client and an AMQP broker. AMQP is multi-channeled, which means that channels are multiplexed over a single network socket connection. Channels are  light-weight and cheap, and therefore used in AMQP's exception handling mechanism--channels are closed when an exception occurs.</p>
    <p>Let's create two channels--one for publishing messages to an exchange and one for consuming messages from a queue. To do this, perform the following step:</p>
    <ol>
      <li><p>Click <strong>New Channel</strong> twice.</p>
        <p>Your <strong>Channel</strong> list should now have two entries. The channels are identified by number.</p></li>
      </ol>

    <fieldset>
        <legend>Create Channels</legend>
        <label for="channelCloseChannel">Channel</label>
        <select id="channelCloseChannel"></select>
        <br>
        <button id="openChannel">New Channel</button>
        <button id="closeChannel">Close Channel</button>
</fieldset>


<h2><a name="creating_exchanges"></a>Declaring an Exchange</h2>


<p>AMQP messages are published to exchanges. Messages contain a <em>routing key</em> that contains the information about the message's destination. The exchange  accepts messages and their routing keys and delivers them to a message queue. You can think of an exchange as an electronic mailman   that delivers the messages to a mailbox (the queue) based on the address on the message's envelope (the routing key). Exchanges do not store messages.</p>
<p>AMQP defines different exchange types. Some of these exchange types (Direct, Fanout, and Topic)  must be supported by all AMQP brokers  while others (Headers and System) are optional. AMQP brokers can also support custom exchange types.The following are the different types of exchanges:</p>
<ul class="arrow-2">
  <li><strong>Direct</strong>--Messages  are sent only to a queue that is bound with a binding key that matches the message's routing key.</li>
  <li><strong>Fanout</strong>--Messages are  sent to every queue that is bound to the exchange.</li>
  <li><strong>Topic</strong>--Messages are sent to a queue based on categorical binding keys and wildcards.</li>
  <li><strong>Headers</strong>--Messages are sent to a queue based on their header property values.</li>
  <li><strong>System</strong>--Messages are sent to system services.</li>
</ul>
 <p>Exchanges can be <em>durable</em>, meaning that the exchange   survives broker shut-down and must be deleted manually or <em>non-durable</em> (temporary) meaning that the exchange lasts only until the broker is shut down. Finally, to check if an exchange exists on the AMQP broker (without actually creating it), you can create a <em>passive</em> exchange.</p>

<p><span>  Let's declare</span> a fanout exchange called <span class="code_inline">myexchange</span>. To do this, perform the following steps:</p>
<ol>
  <li>Select channel <span class="code_inline">1</span> (one of the two channels that was created in the previous step).</li>
  <li>If necessary, type <span class="code_inline">myexchange</span> in the <strong>Exchange Name</strong> text box.</li>
  <li>Select <span class="code_inline">fanout</span> from the <strong>Exchange Type</strong> dropdown list.</li>
  <li>Do <em>not</em> check any of the check boxes.</li>
  <li>Click <strong>Declare Exchange</strong> to declare a fanout exchange that messages can be published to. The message <span class="code_inline">myexchange declared</span> will display.</li>
</ol><br>

<fieldset>
        <legend>Declare Exchange</legend>
        <div class="output" id="exchangeoutput"></div>
        <label for="exchangesChannel">Channel</label>
        <select id="exchangesChannel"></select>
        <br>
        <label for="exchangename">Exchange Name</label>
        <input type="text" id="exchangename" value="myexchange">
        <br>
        <label for="exchangetype">Exchange Type</label>
        <select id="exchangetype">
            <option>fanout</option>
            <option>direct</option>
            <option>topic</option>
            <option>header</option>
            <option>system</option>
        </select>
        <br>

        <fieldset>
        <legend>Options</legend>
        <input type="checkbox" id="passiveE"  class="checkbox">
        <label for="passiveE">Passive</label>
        <input type="checkbox" id="durableE"  class="checkbox">
        <label for="durableE">Durable</label>
        <input type="checkbox"  class="hidden" id="nowaitE" >
        <label for="nowaitE" class="hidden">No Wait</label>
        </fieldset>

        <br>
        <button id="declareExchange">Declare Exchange</button>
</fieldset>


<h2><a name="creating_queues"></a>Declaring a Queue</h2>

    <p>AMQP messages are consumed from queues. You can think of a queue as a mailbox; messages addressed to a particular address (the routing key) are placed in the mailbox for the consumer to pick up. If multiple consumers are bound to a single queue, only one of the consumers  receives the message (the one that picked up the mail).</p>
    
		<p>To check if a queue exists on the AMQP broker (without creating it), you can create a <em>passive</em> queue. Additionally, queues can be marked <em>exclusive</em>, which means that they are tied to a specific connection.     If a queue is marked exclusive, it is deleted when the connection on which it was created is closed.</p>

    <p>Queues can be <em>durable</em>, meaning that the queue   survives broker shut-down and must be deleted manually or <em>non-durable</em> (temporary) meaning that the queue lasts only until the broker is shut down. Queues can  also be marked  Auto Delete, which means that the queue is automatically deleted  when it is no longer in use.</p>

    <p>Let's declare a temporary queue called <span class="code_inline">myqueue</span> on channel 2. You'll use this queue to consume the messages that were published on  channel 1. To do this, perform the following steps:</p>
    <ol>
      <li>Select channel <span class="code_inline">2</span>.</li>
      <li>If necessary, type <span class="code_inline">myqueue</span> in  the <strong>Queue Name</strong> text box.</li>
      <li>Do <em>not</em> check any of the check boxes.</li>
      <li>Click <strong>Declare Queue</strong> to declare a queue that messages can be consumed from. The message <span class="code_inline">myqueue has 0 messages and 0 consumers</span> appears.</li>
      </ol><br>

    <fieldset>
        <legend>Declare Queue</legend>
        <div class="output" id="queueoutput"></div>

        <label for="queuesChannel">Channel</label>
        <select id="queuesChannel"></select>
        <br>

        <label for="queueNameQ">Queue Name</label>
        <input type="text" id="queueNameQ" value="myqueue">
        <br>

        <fieldset>
            <legend>Options</legend>
            <input type="checkbox" id="passiveQ"  class="checkbox">
            <label for="passiveQ">Passive</label>
            <input type="checkbox" id="durableQ"  class="checkbox">
            <label for="durableQ">Durable</label>
            <input type="checkbox" id="exclusiveQ"  class="checkbox">
            <label for="exclusiveQ">Exclusive</label>
            <input type="checkbox" id="autodeleteQ"  class="checkbox">
            <label for="autodeleteQ">Auto Delete</label>
            <input type="checkbox" id="nowaitQ" class="hidden" >
            <label for="nowaitQ" class="hidden">No Wait</label>
      </fieldset>

        <br>

        <button id="declareQueue">Declare Queue</button>
</fieldset>




<h2><a name="binding_queues"></a>Binding an Exchange to a Queue</h2>

 <p>Once you have created an exchange and a queue in AMQP, you must bind--or map--one to the other so that  messages published to a specific exchange are delivered to a particular queue. You bind a queue to an exchange with a <em>routing key</em>.</p>
 
 <p>Let's bind the exchange and the queue that you previously declared to each other with a routing key called <span class="code_inline">myroutingkey</span>. To do this, perform the following steps:</p>
 
 <ol>
   <li>Select one of the channels (for example, channel <span class="code_inline">2</span>).</li>
   <li>Accept the default names.</li>
   <li>Click <strong>Bind</strong>. The message <span class="code_inline">myexchange bound</span> appears.</li>
 </ol><br>

 <fieldset>
        <legend>Bind Exchange to Queue</legend>
        <div class="output" id="bindoutput"></div>

        <label for="bindChannel">Channel</label>
        <select id="bindChannel"></select>
        <br>
        <label for="queuenameB">Queue Name</label>
        <input type="text" id="queuenameB" value="myqueue">
        <br>
        <label for="exchangenameB">Exchange Name</label>
        <input type="text" id="exchangenameB" value="myexchange">
        <br>
        <label for="routingkeyB">Routing Key Name</label>
        <input type="text" id="routingkeyB" value="myroutingkey">

        <fieldset class="hidden">
            <legend>Options</legend>
            <input type="checkbox"  class="hidden" id="nowaitB"  class="checkbox">
            <label for="nowaitB" class="hidden">No Wait</label>
        </fieldset>
        <br>
        <button id="bind">Bind</button>
</fieldset>


<h2><a name="publishing_messages"></a>Publishing Messages</h2>
 <p>Messages are published to exchanges. The established binding rules (routing keys) then determine to which queue a message is delivered. Messages have content, which  consists of two parts:</p>
<p>
	<ol>
  	<li><strong>Content Header:</strong> A set of  properties that describes the message.</li>
		<li><strong>Content Body:</strong> A blob of binary data.</li>
	</ol>
</p>
 <p>Additionally, messages can be marked <em>Mandatory</em> to send a notification to the publisher in case a message cannot be delivered to a queue. You can also mark a message <em>Immediate</em> and the message is returned to the sender  if it cannot be routed to a queue consumer immediately.</p>

 <p>Let's publish a few simple messages. To do this, <span>perform the following steps:</span></p>
 <ol>
   <li>Select channel <span class="code_inline">1</span>.</li>
   <li>Accept the default values for the <strong>Exchange Name</strong> and <strong>Routing Key Name</strong> and leave all check boxes unchecked.</li>
   <li>Enter&quot;<span class="code_inline">A plain text message</span>&quot; in the <strong>Message Body</strong> text box and click <strong>Publish</strong>
     <p>You won't see any results yet (in the <a href="#consuming_messages">Consuming Messages</a> section), but the messages are now waiting in the queue on the broker, ready to be consumed. You  consume the messages  in the next step.</p></li>
   </ol>

 <fieldset>
        <legend>Publish Messages</legend>
        <label for="publishChannel">Channel</label>
        <select id="publishChannel"></select>
        <br>
        <label for="exchangenamePub">Exchange Name</label>
        <input type="text" id="exchangenamePub" value="myexchange">
        <br>
        <label for="routingkeyPub">Routing Key Name</label>
        <input type="text" id="routingkeyPub" value="myroutingkey">
        <br>
        <label for="textmessagePub">Message Body</label>
        <input type="text" id="textmessagePub" value="A plain text message">
        <br>

        <fieldset>
            <legend>Options</legend>
            <input type="checkbox" id="mandatoryPub"  class="checkbox">
            <label for="mandatoryPub">Mandatory</label>
            <input type="checkbox" id="immediatePub"  class="checkbox">
            <label for="immediatePub">Immediate</label>
        </fieldset>
        <br>

        <button id="send">Publish</button>
</fieldset>





<h2><a name="consuming_messages"></a>Consuming Messages</h2>
<p>Once messages are published, they can be consumed from a queue. A variety of options can be applied to  messages in a queue. For example, publishers  can choose to require acknowledgement (or not) of messages so that messages can be redelivered in the case of a delivery failure. If the queue is set to <em>Exclusive</em>, it is scoped to just the current connection and deleted when the connection<strong> </strong>on which it was established is closed. Additionally, you can use the <em>No Local </em>setting to notify the broker  <em>not</em> to send messages to the connection on which the messages were published.</p>
<p>Let's consume some messages from the previously created queue. To do this, perform the following steps:</p>
<ol>
  <li>Select channel <span class="code_inline">2</span>.</li>
  <li>Accept the default values for <strong>Queue Name</strong> and <strong>Consumer Tag</strong> (the unique identifier for a subscription) and leave all the check boxes unchecked.</li>
  <li><p>Click <strong>Consume</strong>.</p>
    <p>The message  &quot;<span class="code_inline">a plain text message</span>&quot; that you published earlier should now appear in this section.</p></li>
  <li><p>Go back to the <a href="#publishing_messages">Publishing Messages</a> section and publish a few more text messages (type in some new text).</p>
    <p>The messages appear immediately in the <a href="#consuming_messages">Consuming Messages</a> section, but in reality they have been published to the exchange on the AMQP broker, then routed to a queue on the broker, and finally consumed by the client--it's an example of real-time HTML5 WebSocket in action!</p></li>
  </ol>

<fieldset>
    <legend>Consume Messages</legend>
    <div class="output" id="consumeoutput"></div>

    <label for="consumeChannel">Channel</label>
    <select id="consumeChannel"></select>

        <br>
        <label for="queuenameCon">Queue Name</label>
        <input type="text" id="queuenameCon" value="myqueue">
        <br>
        <label for="consumertagCon">Consumer Tag</label>
        <input type="text" id="consumertagCon" value="myconsumertag">
        <br>
    <fieldset>
        <legend>Options</legend>
        <input type="checkbox" id="nolocalCon"  class="checkbox">
        <label for="nolocalCon">No Local</label>
        <input type="checkbox" id="noackCon"  class="checkbox">
        <label for="noackCon">No Ack</label>
        <input type="checkbox" id="exclusiveCon"  class="checkbox">
        <label for="exclusiveCon">Exclusive</label>
        <input type="checkbox"  class="hidden" id="nowaitCon" >
        <label for="nowaitCon" class="hidden">No Wait</label>
    </fieldset>
    <br>
    <button id="consume">Consume</button>
    <button id="cancel">Cancel (Stop Consuming)</button>
    </fieldset>


    <h2><a name="using_transactions"></a>Using Transactions</h2>
    <p>AMQP supports transactional messaging through <em>server local transactions</em>. When the client commits the transaction, the server publishes a set of messages as one unit. Transactions only apply to message publishing and not to the actual delivery of the messages or the consumption of the messages from a queue. Consequently, rolling back a transaction (canceling the transaction before it is committed) does not remove any messages from a queue.</p>

		<span class="note"><b>Note:</b> Once you commit a transaction on a channel, a new transaction is started automatically. For this reason you must commit  all future messages you want to publish on that channel or create a new, non-transactional channel to publish messages on.</span><br>
		
    <p>Let's use a transaction to publish some messages. To do this, perform the following steps:</p>
    <ol>
      <li>Select a the same channel as the one you are publishing on (channel <span class="code_inline">1</span> in this case).</li>
      <li>Click <strong>Select</strong>.</li>
      <li>Go to the <a href="#publishing_messages">Publishing Messages</a> section and publish two or three messages with the text &quot;<span class="code_inline">Transaction</span>&quot; to channel <span class="code_inline">1</span>.</li>
      <li>In the <a href="#consuming_messages">Consuming Messages</a> section, check that these messages do <em>not</em> appear  yet; they should only appear there <em>after</em> the transaction has been committed.</li>
      <li>Click <strong>Commit</strong> to commit the transaction.</li>
      <li><p>Check the <a href="#consuming_messages">Consuming Messages</a> section again.</p>
        <p>The &quot;<span class="code_inline">Transaction</span>&quot; messages should now display.</p></li>
    </ol>

    <fieldset>
        <legend>Use Transactions</legend>
        <div class="output" id="txoutput"></div>

<label for="txChannel">Channel</label>
        <select id="txChannel"></select>
        <br>
        <button id="select">Select</button>
        <button id="commit">Commit</button>
        <button id="rollback">Rollback</button>
</fieldset>

<h2><a name="control_flow"></a>Controlling Message Flow</h2>

    <p>You can use flow control in AMQP to temporarily--or permanently--halt the flow of messages from a publisher to a consumer. If you turn the message flow off, no messages are sent to the consumer.</p>
    <p>Finally, let's take a look at what happens when you turn the message flow on a channel off and on. To do that, perform the following steps:</p>
    <ol>
      <li>Select the channel on which you are consuming messages (Channel <span class="code_inline">2</span>).</li>
      <li>Click <strong>Flow Off</strong></li>
      <li>Go to the <a href="#publishing_messages">Publishing Messages</a> section and publish three messages with the text &quot;<span class="code_inline">Flow Test</span>&quot;.</li>
      <li>Go to the <a href="#using_transactions">Using Transactions</a> section and click <strong>Commit</strong> (Channel <span class="code_inline">1</span> was changed to use transactions in the previous step).</li>
      <li>Check the <a href="#consuming_messages">Consuming Messages</a> section to see if the messages appeared (they shouldn't have).</li>
      <li>Clicking <strong>Flow On</strong> to turn the message flow back on.</li>
      <li><p>Check the <a href="#consuming_messages">Consuming Messages</a> section.</p>
        <p>The &quot;<span class="code_inline">Flow Test</span>&quot; message should now appear in the <a href="#consuming_messages">Consuming Messages</a> section.</p></li>
      </ol>

    <fieldset>
        <legend>Control Message Flow</legend>
        <div class="output" id="flowoutput"></div>

        <label for="flowChannel">Channel</label>
        <select id="flowChannel"></select>
        <br>
        <button id="trueFlow">Flow On</button>
<button id="falseFlow">Flow  Off</button>
</fieldset>
<h2><a name="summary"></a>Summary</h2>
<p>In this interactive, step-by-step document you have seen how the main features of AMQP work. Although not every single protocol feature was explained or shown in this guide,  you should now have a  good overview of what is possible with AMQP and you may be able to think of some practical use cases for AMQP. For more information on how to write your own AMQP Web client, refer to  the document <a href="http://developer.kaazing.com/documentation/amqp/4.0/dev-js/o_dev_js.html">Checklist: How to Build JavaScript Clients Using Kaazing WebSocket Gateway</a>.</p>
</body>
</html>
